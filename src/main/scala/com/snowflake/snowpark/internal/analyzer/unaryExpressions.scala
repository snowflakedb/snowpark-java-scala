package com.snowflake.snowpark.internal.analyzer

import com.snowflake.snowpark.types.DataType

private[snowpark] trait UnaryExpression extends Expression {
  def child: Expression
  def sqlOperator: String
  def operatorFirst: Boolean

  override def toString: String =
    if (operatorFirst) {
      s"($sqlOperator $child)"
    } else {
      s"($child $sqlOperator)"
    }
  override final def children: Seq[Expression] = Seq(child)
  override def nullable: Boolean = child.nullable

  protected val createAnalyzedUnary: Expression => Expression

  override protected def createAnalyzedExpression(analyzedChildren: Seq[Expression]): Expression =
    createAnalyzedUnary(analyzedChildren.head)
}

private[snowpark] case class Cast(child: Expression, to: DataType) extends UnaryExpression {
  override def sqlOperator: String = "CAST"
  override def operatorFirst: Boolean = true

  override protected val createAnalyzedUnary: Expression => Expression = Cast(_, to)
}

private[snowpark] case class UnaryMinus(child: Expression) extends UnaryExpression {
  override def sqlOperator: String = "-"
  override def operatorFirst: Boolean = true

  override protected val createAnalyzedUnary: Expression => Expression = UnaryMinus
}

private[snowpark] case class IsNull(child: Expression) extends UnaryExpression {
  override def sqlOperator: String = "IS NULL"
  override def operatorFirst: Boolean = false

  override protected val createAnalyzedUnary: Expression => Expression = IsNull
}

private[snowpark] case class IsNotNull(child: Expression) extends UnaryExpression {
  override def sqlOperator: String = "IS NOT NULL"
  override def operatorFirst: Boolean = false

  override protected val createAnalyzedUnary: Expression => Expression = IsNotNull
}

private[snowpark] case class IsNaN(child: Expression) extends UnaryExpression {
  override def sqlOperator: String = "= 'NaN'"
  override def operatorFirst: Boolean = false

  override protected val createAnalyzedUnary: Expression => Expression = IsNaN
}

private[snowpark] case class Not(child: Expression) extends UnaryExpression {
  override def sqlOperator: String = "NOT"
  override def operatorFirst: Boolean = true

  override protected val createAnalyzedUnary: Expression => Expression = Not
}

// isInternal: whether this alias generated by Snowpark client or not. e.g. Join
private[snowpark] case class Alias(child: Expression, name: String, isInternal: Boolean = false)
    extends UnaryExpression
    with NamedExpression {
  override def sqlOperator: String = "AS"
  override def operatorFirst: Boolean = false
  override def toString: String = s"$child $sqlOperator $name"

  override protected val createAnalyzedUnary: Expression => Expression = Alias(_, name)
}

private[snowpark] case class DfAlias(child: Expression, name: String)
  extends UnaryExpression
    with NamedExpression {
  override def sqlOperator: String = ""
  override def operatorFirst: Boolean = false
  override def toString: String = ""

  override protected val createAnalyzedUnary: Expression => Expression = DfAlias(_, name)
}

private[snowpark] case class UnresolvedAlias(
    child: Expression,
    aliasFunc: Option[Expression => String] = None)
    extends UnaryExpression
    with NamedExpression {
  override def sqlOperator: String = "AS"
  override def operatorFirst: Boolean = false
  override def name: String = child.sql

  override protected val createAnalyzedUnary: Expression => Expression =
    UnresolvedAlias(_, aliasFunc)
}
